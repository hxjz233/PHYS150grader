import csv
import os
import toml

HEADERS = ["Student", "ID", "SIS Login ID", "Section"]

def main():

    # Read config and tester
    config = toml.load(os.path.join(os.path.dirname(__file__), "config.toml"))
    HOMEWORK_DIR = config.get("homework_dir", None)
    FEEDBACK_DIR = os.path.join(HOMEWORK_DIR, config.get("feedback_dir", "feedback"))
    GRADEBOOK = os.path.join(os.path.dirname(__file__), "grade_updated.csv")

    os.makedirs(FEEDBACK_DIR, exist_ok=True)
    tester_path = os.path.join(HOMEWORK_DIR, "tester.toml")
    tester = toml.load(tester_path)

    # Read passfail and failmsg CSVs
    pf_path = os.path.join(HOMEWORK_DIR, "test_passfail.csv")
    msg_path = os.path.join(HOMEWORK_DIR, "test_failmsg.csv")
    with open(pf_path, newline='', encoding='utf-8') as f:
        pf_rows = list(csv.reader(f))
    with open(msg_path, newline='', encoding='utf-8') as f:
        msg_rows = list(csv.reader(f))
    header = pf_rows[0][1:]  # skip ID
    id_idx = 0
    pf_data = {row[0]: row[1:] for row in pf_rows[1:]}
    msg_data = {row[0]: row[1:] for row in msg_rows[1:]}

    # Calculate total points per test
    test_pts = []
    for problem in tester["problem"]:
        pts = problem.get("pts", 1)
        ntests = len(problem["tests"])
        for _ in range(ntests):
            test_pts.append(pts / ntests)

    user_grades = {}
    for userid in pf_data:
        txt_path = os.path.join(FEEDBACK_DIR, f"{userid}.txt")
        total_score = 0
        max_score = sum(test_pts)
        with open(txt_path, "w", encoding="utf-8") as f:
            test_idx = 0
            for prob_idx, problem in enumerate(tester["problem"], 1):
                ntests = len(problem["tests"])
                pts = problem.get("pts", 1)
                passed = 0
                prob_score = 0
                fail_msgs = []
                for t in range(ntests):
                    pf = pf_data[userid][test_idx]
                    msg = msg_data[userid][test_idx]
                    if pf == '1':
                        passed += 1
                        prob_score += pts / ntests
                        total_score += pts / ntests
                    elif msg:
                        fail_msgs.append(msg)
                    test_idx += 1
                f.write(f"Prob {prob_idx}: {passed}/{ntests} tests passed, Score: {prob_score:.2f}/{pts}\n")
                if fail_msgs:
                    f.write("\tFailed tests:\n")
                    for fail in fail_msgs:
                        f.write(f"\t\t{fail}\n")
            f.write(f"Total Score: {total_score:.2f}/{max_score}\n")
            f.write("-- generated by PHYS150grader\n")
            f.write("-- reviewed by TA\n")
        user_grades[userid] = total_score

    # Add grade column to gradebook with config.toml homework_title
    homework_title = config.get("homework_title", "New Assignment")
    with open(GRADEBOOK, newline='', encoding='utf-8') as f:
        rows = list(csv.reader(f))
    header = rows[0]
    # Find points possible row (usually 2nd row)
    points_row_idx = None
    for idx, row in enumerate(rows):
        if any("Points Possible" in cell for cell in row):
            points_row_idx = idx
            break
    # Find column index matching homework_title prefix
    col_idx = None
    for i, col in enumerate(header):
        if col.startswith(homework_title):
            col_idx = i
            break
    if col_idx is None:
        # No matching column, append new
        header.append(homework_title)
        col_idx = len(header) - 1
        if points_row_idx is not None:
            # Ensure points possible row has enough columns
            while len(rows[points_row_idx]) < len(header):
                rows[points_row_idx].append("")
            rows[points_row_idx][col_idx] = str(max_score)
        # For other rows, we'll handle length when updating
    
    # Update grades
    for row in rows[1:]:
        if row and len(row) > header.index("ID"):
            id_val = row[header.index("ID")].strip()
            if id_val in user_grades:
                # Ensure row has enough columns
                while len(row) < len(header):
                    row.append("")
                row[col_idx] = f"{user_grades[id_val]:.2f}"

    # Write updated grades to a new CSV file, keeping only essential columns
    updated_gradebook_path = os.path.join(os.path.dirname(__file__), "grade_updated.csv")
    
    # Determine indices of columns to keep
    indices_to_keep = []
    for h in HEADERS:
        if h in header:
            indices_to_keep.append(header.index(h))
    # Add the current assignment column index
    if col_idx is not None:
        indices_to_keep.append(col_idx)

    # Create new list of rows with only the desired columns
    new_rows = []
    new_header_row = [header[i] for i in indices_to_keep]
    
    # Adjust homework title if it was a new column
    if homework_title not in new_header_row:
        new_header_row[-1] = homework_title

    new_rows.append(new_header_row)

    for row in rows[1:]:
        new_row = []
        for i in indices_to_keep:
            if i < len(row):
                new_row.append(row[i])
            else:
                new_row.append("")
        new_rows.append(new_row)

    with open(updated_gradebook_path, "w", newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerows(new_rows)
    print(f"Grades updated and saved to {updated_gradebook_path}")

if __name__ == "__main__":
    main()
