"""
Manual grading and feedback generation using the new modular architecture.
"""
import csv
import os
import sys

# Add the core module to the path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'core'))

from core.config import ConfigManager


def generate_manual_feedback(config_manager: ConfigManager = None):
    """Generate feedback files from test results CSV files."""
    config = config_manager or ConfigManager()
    
    # Essential column headers for gradebook
    HEADERS = ["Student", "ID", "SIS Login ID", "Section"]
    
    # Create feedback directory
    feedback_dir = config.get_feedback_dir()
    os.makedirs(feedback_dir, exist_ok=True)
    
    # Read test results
    homework_dir = config.get_homework_dir()
    pf_path = os.path.join(homework_dir, "test_passfail.csv")
    msg_path = os.path.join(homework_dir, "test_failmsg.csv")
    
    with open(pf_path, newline='', encoding='utf-8') as f:
        pf_rows = list(csv.reader(f))
    with open(msg_path, newline='', encoding='utf-8') as f:
        msg_rows = list(csv.reader(f))
    
    # Parse test data
    header = pf_rows[0][1:]  # skip ID column
    pf_data = {row[0]: row[1:] for row in pf_rows[1:]}
    msg_data = {row[0]: row[1:] for row in msg_rows[1:]}
    
    # Calculate points per test from tester configuration
    test_pts = []
    for problem in config.tester["problem"]:
        pts = problem.get("pts", 1)
        ntests = len(problem["tests"])
        points_per_test = pts / ntests
        for _ in range(ntests):
            test_pts.append(points_per_test)
    
    # Generate feedback for each student
    user_grades = {}
    max_score = sum(test_pts)
    
    for userid in pf_data:
        feedback_path = os.path.join(feedback_dir, f"{userid}.txt")
        total_score = 0
        
        with open(feedback_path, "w", encoding="utf-8") as f:
            test_idx = 0
            
            for prob_idx, problem in enumerate(config.tester["problem"], 1):
                ntests = len(problem["tests"])
                pts = problem.get("pts", 1)
                passed = 0
                prob_score = 0
                fail_msgs = []
                
                # Process each test for this problem
                for t in range(ntests):
                    pf = pf_data[userid][test_idx]
                    msg = msg_data[userid][test_idx]
                    
                    if pf == '1':
                        passed += 1
                        test_score = pts / ntests
                        prob_score += test_score
                        total_score += test_score
                    elif msg:
                        fail_msgs.append(msg)
                    
                    test_idx += 1
                
                # Write problem summary
                f.write(f"Prob {prob_idx}: {passed}/{ntests} tests passed, "
                       f"Score: {prob_score:.2f}/{pts}\n")
                
                # Write failed test messages
                if fail_msgs:
                    f.write("\tFailed tests:\n")
                    for fail in fail_msgs:
                        f.write(f"\t\t{fail}\n")
            
            # Write total score and footer
            f.write(f"Total Score: {total_score:.2f}/{max_score}\n")
            f.write("-- generated by PHYS150grader\n")
            f.write("-- reviewed by TA\n")
        
        user_grades[userid] = total_score
    
    return user_grades, max_score


def update_gradebook(user_grades, max_score, config_manager: ConfigManager = None):
    """Update the gradebook with computed grades."""
    config = config_manager or ConfigManager()
    
    # Essential column headers
    HEADERS = ["Student", "ID", "SIS Login ID", "Section"]
    
    gradebook_path = os.path.join(os.path.dirname(__file__), "grade_updated.csv")
    homework_title = config.get_homework_title()
    
    # Read current gradebook
    with open(gradebook_path, newline='', encoding='utf-8') as f:
        rows = list(csv.reader(f))
    
    header = rows[0]
    
    # Find points possible row
    points_row_idx = None
    for idx, row in enumerate(rows):
        if any("Points Possible" in cell for cell in row):
            points_row_idx = idx
            break
    
    # Find or create homework column
    col_idx = None
    for i, col in enumerate(header):
        if col.startswith(homework_title):
            col_idx = i
            break
    
    if col_idx is None:
        # Create new column
        header.append(homework_title)
        col_idx = len(header) - 1
        
        if points_row_idx is not None:
            # Ensure points possible row has enough columns
            while len(rows[points_row_idx]) < len(header):
                rows[points_row_idx].append("")
            rows[points_row_idx][col_idx] = str(max_score)
    
    # Update grades for each student
    for row in rows[1:]:
        if row and len(row) > header.index("ID"):
            id_val = row[header.index("ID")].strip()
            if id_val in user_grades:
                # Ensure row has enough columns
                while len(row) < len(header):
                    row.append("")
                row[col_idx] = f"{user_grades[id_val]:.2f}"
    
    # Determine columns to keep in output
    indices_to_keep = []
    for h in HEADERS:
        if h in header:
            indices_to_keep.append(header.index(h))
    
    # Add the current assignment column
    if col_idx is not None:
        indices_to_keep.append(col_idx)
    
    # Create filtered output
    new_rows = []
    new_header_row = [header[i] for i in indices_to_keep]
    
    # Adjust homework title if it was a new column
    if homework_title not in new_header_row:
        new_header_row[-1] = homework_title
    
    new_rows.append(new_header_row)
    
    # Add filtered data rows
    for row in rows[1:]:
        new_row = []
        for i in indices_to_keep:
            if i < len(row):
                new_row.append(row[i])
            else:
                new_row.append("")
        new_rows.append(new_row)
    
    # Write updated gradebook
    with open(gradebook_path, "w", newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerows(new_rows)
    
    print(f"Grades updated and saved to {gradebook_path}")


def main():
    """Main entry point for manual grading."""
    config = ConfigManager()
    
    print("Generating manual feedback from test results...")
    user_grades, max_score = generate_manual_feedback(config)
    
    print("Updating gradebook...")
    update_gradebook(user_grades, max_score, config)
    
    print(f"Manual grading complete. Processed {len(user_grades)} students.")


if __name__ == "__main__":
    main()